riml_include 'view.riml'

def maque#tmux#layout#cmp_pane_height(p1, p2)
  pos1 = p1.layout_position()
  pos2 = p2.layout_position()
  return pos1 == pos2 ? 0 : pos1 > pos2 ? 1 : -1
end

class Layout < g:View

  def initialize(name, args)
    super(name, args)
    self.panes = []
    self.direction = get(a:args, 'direction', 'vertical')
    self.layout = 0
  end

  defm add(pane)
    add(self.panes, pane)
    pane.layout = self
  end

  defm create
    unless self.open()
      if self.in_layout() && len(self.panes) > 0
        self.layout.create_pane(self.panes[0])
      else
        maque#tmux#command_output(self.creator())
      end
    end
  end

  defm create_pane(pane) abort
    if self.in_layout()
      self.layout.create_kids()
    end
    panes_before = maque#tmux#pane#all()
    unless pane.open()
      if self.open()
        self.split(pane)
        maque#tmux#pane('vim').focus()
      else
        self.create()
      end
      pane.determine_id(panes_before)
      pane.post_create()
      self.pack()
    end
  end

  defm pack
    if !g:maque_tmux_exiting
      stretch_size = self.stretch_size()
      for pane in self.open_panes()
        self.pack_pane(pane, stretch_size)
      end
    end
  end

  defm pack_pane(pane, stretch_size)
    if pane.fixed_size()
      pane.set_preferred_size()
    else
      pane.apply_size(stretch_size)
    end
  end

  defm close
    for pane in self.open_panes()
      pane.close()
    end
  end

  defm open
    return !empty(self.open_panes())
  end

  defm focus
    if self.open()
      pane = self.ref_pane()
      pane.focus()
    end
  end

  defm split(pane)
    splitter = self.splitter() . ' ' . self.target_pane_param() . ' ' .
          \ pane.splitter_params()
    maque#tmux#command_output(splitter)
  end

  defm target_pane_param
    return '-t ' . self.pane_id()
  end

  defm set_preferred_size
    if self.open()
      self.ref_pane().set_preferred_size()
    end
  end

  " TODO use logic from stretch_size to determine this as total_size()
  defm current_size
    if self.open()
      return self.ref_pane().current_size()
    else
      return [0, 0]
    end
  end

  defm resize(width, height)
    if self.open()
      self.ref_pane().resize(width, height)
    end
  end

  defm splitter
    return self.layout_vertical() ? 'splitw -v -d' : 'splitw -h -d'
  end

  defm creator
    return self.layout_vertical() ? 'splitw -h -d' : 'splitw -v -d'
  end

  defm in_layout
    return type(self.layout) != type(0)
  end

  defm determine_id(*args)
  end

  defm post_create
  end

  defm create_kids
    for pane in self.panes
      pane.create_and_wait() unless pane.open()
    end
  end

  defm create_and_wait(timeout=5)
    self.create()
    counter = 0
    while (!self.open()) && (counter < timeout * 10)
      :sleep 100m
      counter += 1
    end
  end

  def open_panes
    panes = []
    for pane in self.panes
      add(panes, pane) if pane.open()
    end
    return panes
  end

  def open_panes_sorted
    return sort(self.open_panes(), 'maque#tmux#layout#cmp_pane_height')
  end

  def any_pane
    return self.open_panes()[0]
  end

  defm ref_pane
    panes = self.open_panes_sorted()
    return panes[0]
  end

  defm pane_id
    return self.ref_pane().pane_id()
  end

  defm current_size
    return self.any_pane().current_size()
  end

  defm current_position
    return self.any_pane().current_position()
  end

  defm stretch_size
    total_size = 0
    fixed_pane_size = 0
    stretch_count = 0
    index = self.layout_vertical() ? 1 : 0
    for pane in self.open_panes()
      total_size += pane.current_size()[index]
      if pane.fixed_size()
        fixed_pane_size += pane.effective_size()
      else
        stretch_count += 1
      end
    end
    return stretch_count ? ((total_size - fixed_pane_size) / stretch_count) : 0
  end

  defm layout_vertical
    return self.direction == 'vertical'
  end
end

def maque#tmux#layout#new(name, args={})
  return new Layout(name, args)
end
