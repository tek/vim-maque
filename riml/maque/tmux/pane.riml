riml_include 'view.riml'

use_cache = 0
cached_panes = {}

def maque#tmux#pane#enable_cache
  maque#tmux#pane#disable_cache()
  maque#tmux#pane#all()
  s:use_cache = 1
end

def maque#tmux#pane#disable_cache
  s:use_cache = 0
end

def parse_tmux_output(line)
  values = split(line)
  return {
        \ 'id': get(values, 0, ''),
        \ 'pid': get(values, 1, 1) + 0,
        \ 'width': get(values, 2, 0) + 0,
        \ 'height': get(values, 3, 0) + 0,
        \ 'left': get(values, 4, 0) + 0,
        \ 'top': get(values, 5, 0) + 0,
        \ }
end

def maque#tmux#pane#all(*args)
  force = get(args, 0)
  if !s:use_cache || force
    cmd = 'list-panes -a -F "#{pane_id} #{pane_pid} #{pane_width}' .
          \ ' #{pane_height} #{pane_left} #{pane_top}"'
    lines = split(maque#tmux#command_output(cmd), "\n")
    s:cached_panes = {}
    for line in lines
      data = parse_tmux_output(line)
      s:cached_panes[data.id] = data
    end
  end
  return s:cached_panes
end

def maque#tmux#pane#size(id)
  panes = maque#tmux#pane#all()
  if has_key(panes, id)
    pane = panes[id]
    return [pane.width, pane.height]
  else
    return [0, 0]
  end
end

def maque#tmux#pane#position(id)
  panes = maque#tmux#pane#all()
  if has_key(panes, id)
    pane = panes[id]
    return [pane.left, pane.top]
  else
    return [0, 0]
  end
end

class Pane < g:View

  def initialize(name, params={})
    attrs = {
          \ 'id': -1,
          \ 'errorfile': tempname(),
          \ '_splitter': 'tmux neww -d',
          \ 'eval_splitter': 0,
          \ 'capture': 1,
          \ 'autoclose': 0,
          \ '_last_killed': 0,
          \ '_killed': 0,
          \ 'shell_pid': 0,
          \ 'command_pid': 0,
          \ 'wait_before_autoclose': 2,
          \ 'create_minimized': 0,
          \ 'restore_on_make': 1,
          \ 'kill_running_on_make': 1,
          \ 'focus_on_make': 0,
          \ 'manual_termination': 0,
          \ 'layout': 0,
          \ 'minimal_shell': 0,
          \ 'compiler': '',
          \ 'nested': 0,
          \ 'quit_copy_mode': 1,
          \ }
    extend(attrs, params)
    self.command_executable = ''
    self.spawning_make = 0
    super(name, attrs)
  end

  defm create
    unless self.open()
      if self.in_layout()
        self.layout.create_pane(self)
      else
        self.create_free()
      end
    end
  end

  defm create_free
    unless self.open()
      panes_before = maque#tmux#pane#all()
      maque#util#system(self.splitter(), 1)
      self.determine_id(panes_before)
      self.post_create()
    end
  end

  defm determine_id(panes_before)
    matcher = 'index(keys(a:panes_before), v:val) == -1'
    matches = filter(keys(maque#tmux#pane#all(1)), matcher)
    self.id = len(matches) > 0 ? matches[0] : -1
  end

  defm post_create
    if self.open()
      self.minimized = 0
      if self.create_minimized
        self.toggle()
      end
      self.send(' cd '.getcwd())
      self.set_shell_pid()
    end
  end

  defm create_and_wait(timeout=1)
    self.create()
    counter = 0
    while (!self.open()) && (counter < timeout * 10)
      :sleep 100m
      counter += 1
    end
  end

  defm make(cmd, *args)
    capture = get(args, 0, self.capture)
    autoclose = get(args, 1, self.autoclose)
    if self.ready_for_make()
      if self.minimized && self.restore_on_make
        self.restore()
      end
      self.send('') if self.quit_copy_mode
      self.send(cmd)
      if capture
        if !self.manual_termination
          " send the pipe canceling command now, so that it executes as soon as the
          " make command is finished
          " omit this if manual_termination is set, i.e. the program is
          " interactive or just doesn't terminate automatically (guard, log)
          self.send(' tmux '.self.pipe_cmd())
        end
        " initiate the pipe to the errorfile after starting the command, so that it
        " doesn't contain the command line
        self.pipe_to_file()
      end
      if autoclose
        self.send(' sleep '.self.wait_before_autoclose .'; exit')
      end
      if self.focus_on_make
        self.focus()
      end
    else
      maque#util#warn('make called on pane "'.self.name .'" while not open!')
    end
    self.spawning_make = 0
  end

  defm create_and_make(cmd, *args)
    self.spawning_make = 1 unless self.open()
    self.create()
    :call call(self.make, [a:cmd] + a:000, self)
  end

  " Send a signal to the command.
  " Iterates g:maque_tmux_kill_signals for subsequent calls until the process
  " is dead (default INT, TERM, KILL)
  " Argument overrides the employed signal and does not advance the current
  " signal.
  defm kill(signal='0')
    force_signal = (signal != '0')
    if self.process_alive()
      if self.command_pid != self._last_killed
        self._killed = 0
        self._last_killed = self.command_pid
      end
      signal = next_signal(self._killed) unless force_signal
      self._kill(signal)
      self._killed += 1 unless force_signal
      return 1
    else
      maque#util#warn('no process running!')
    end
  end

  defm _kill(signal)
    maque#util#system('kill -'.signal.' '.self.command_pid, 1)
    maque#util#warn('sent SIG'.signal. " to pane '".self.name ."'!")
  end

  defm kill_wait
    for index in range(len(g:maque_tmux_kill_signals))
      self.kill()
      return 1 unless self.process_alive()
      sleep 1
      return 1 unless self.process_alive()
    end
    return !self.process_alive()
  end

  " execute a shell command in the target pane
  defm send(cmd)
    self.send_keys("'".cmd."' 'ENTER'")
  end

  " send input to the target pane
  defm send_keys(cmd)
    maque#tmux#command('send-keys -t '.self.id .' '.cmd)
  end

  defm open
    return has_key(maque#tmux#pane#all(), self.id)
  end

  " Kill the pane if it's open, reset pids in any case
  defm close
    if self.open()
      maque#tmux#command('kill-pane -t '.self.id)
    end
    self.command_pid = 0
    self.shell_pid = 0
    maque#tmux#pane#enable_cache()
    self.pack_layout()
  end

  defm current_size
    return maque#tmux#pane#size(self.id)
  end

  defm height
    return self.current_size()[1]
  end

  defm current_position
    return maque#tmux#pane#position(self.id)
  end

  " Restore the size given by the constructor parameters 'size' or
  " 'minimized_size', whichever is appropriate
  defm set_preferred_size
    if self.minimized
      self.apply_size(self.minimized_size)
    elseif self.fixed_size()
      self.apply_size(self.size)
    end
  end

  defm resize(width, height)
    cmd = 'resize-pane -t '.self.id
    cmd .= ' -x '.width if width > 0
    cmd .= ' -y '.height if height > 0
    maque#tmux#command(cmd)
  end

  defm focus
    maque#tmux#command('select-pane -t '.self.id)
  end

  defm pipe_to_file
    filter = g:maque_tmux_filter_escape_sequences ?
          \ g:maque_tmux_pane_escape_filter : 'tee'
    redirect = filter . ' > '.self.errorfile
    maque#tmux#command(self.pipe_cmd().' '.shellescape(redirect))
  end

  defm pipe_cmd
    return 'pipe-pane -t '.self.id
  end

  defm reset_capture
    maque#tmux#command(self.pipe_cmd())
    delete(self.errorfile)
    self.pipe_to_file()
  end

  defm output
    return filereadable(self.errorfile) ? readfile(self.errorfile) : []
  end

  defm description
    return 'tmux pane "'.self.name .'"'
  end

  defm splitter
    if self.in_layout()
      splitter = self.layout.splitter()
    else
      if self.eval_splitter
        splitter = eval(self._splitter)
      else
        splitter = self._splitter
      end
    end
    return splitter . self.splitter_params()
  end

  defm set_shell_pid
    panes = maque#tmux#pane#all()
    if has_key(panes, self.id)
      self.shell_pid = panes[self.id].pid
    end
  end

  defm set_command_pid
    self.command_pid = 0
    if self.open()
      pids = maque#util#child_pids(self.shell_pid)
      [pid, comm] = empty(pids) ? [0, ''] : pids[0]
      self.command_pid = pid + 0
      self.command_executable = comm
    end
    return self.command_pid
  end

  defm set_command_executable
    self.set_command_pid()
    return self.command_executable
  end

  defm process_alive
    return self.set_command_pid() > 0
  end

  " check whether it's ok to dispatch a command.
  " This kills the running process (if configured), which is undesirable when
  " calling make while the pane was closed, as it will mistake the shell
  " initialization subprocesses, if any, for commands.
  " For that purpose, the 'spawning_make' flag is set in the special function
  " create_and_make, and used here to prevent killing the process.
  defm ready_for_make
    return self.open() && (self.spawning_make ||
          \ !self.process_alive() ||
          \ self._handle_running_process())
  end

  defm in_layout
    return type(self.layout) != type(0)
  end

  defm splitter_params
    params = ''
    params .= ' "' . g:maque_tmux_minimal_shell . '"' if self.minimal_shell
    return params
  end

  defm _handle_running_process
    if self.nested
      return 1
    elseif self.kill_running_on_make
      if self.kill_wait()
        return 1
      else
        maque#util#warn('Failed to kill running process!')
      end
    else
      maque#util#warn('Refusing to kill running process!')
    end
  end

  defm pane_id
    return self.id
  end

  defm clear_log
    self.send(repeat("\n", self.height() - 2))
  end
end

def next_signal(idx)
  sigs = g:maque_tmux_kill_signals
  return sigs[min([idx, len(sigs)-1])]
end

def maque#tmux#pane#new(name, params={})
  return new Pane(name, params)
end

class VimPane < Pane

  def initialize(params={})
    super('vim', params)
  end

  defm open
    self.id = maque#tmux#vim_id() if self.id == -1
    return super()
  end
end

def maque#tmux#pane#new_vim(params={})
  return new VimPane(params)
end
