use_cache = 0
cached_panes = {}

def maque#tmux#pane#enable_cache
  maque#tmux#pane#all()
  s:use_cache = 1
end

def maque#tmux#pane#disable_cache
  s:use_cache = 0
end

def parse_tmux_output(line)
  values = split(line)
  return {
        \ 'id': values[0],
        \ 'pid': values[1],
        \ 'width': values[2],
        \ 'height': values[3],
        \ }
end

def maque#tmux#pane#all(*args)
  force = get(args, 0)
  if !s:use_cache || force
    cmd = 'list-panes -a -F "#{pane_id} #{pane_pid} #{pane_width} #{pane_height}"'
    lines = split(maque#tmux#command_output(cmd), "\n")
    s:cached_panes = {}
    for line in lines
      data = parse_tmux_output(line)
      s:cached_panes[data.id] = data
    end
  end
  return s:cached_panes
end

def maque#tmux#pane#size(id)
  panes = maque#tmux#pane#all()
  if has_key(panes, id)
    pane = panes[id]
    return [pane.width, pane.height]
  else
    return [0, 0]
  end
end

class Pane

  def initialize(name, params={})
    attrs = {
          \ 'id': -1,
          \ 'errorfile': tempname(),
          \ '_splitter': 'tmux neww -d',
          \ 'eval_splitter': 0,
          \ 'capture': 1,
          \ 'autoclose': 0,
          \ '_last_killed': 0,
          \ '_killed': 0,
          \ 'shell_pid': 0,
          \ 'command_pid': 0,
          \ 'wait_before_autoclose': 2,
          \ 'minimize_on_toggle': get(g:, 'maque_tmux_minimize_on_toggle', 0),
          \ 'vertical': 1,
          \ 'minimized': 0,
          \ 'minimized_size': 2,
          \ 'create_minimized': 0,
          \ 'restore_on_make': 1,
          \ '_original_size': [0, 0],
          \ 'kill_running_on_make': 1,
          \ 'focus_on_restore': 0,
          \ 'focus_on_make': 0,
          \ 'manual_termination': 0,
          \ 'layout': 0,
          \ 'size': 0,
          \ }
    extend(attrs, params)
    attrs.minimized_size = max([attrs.minimized_size, 2])
    self.name = name
    self.command_executable = ''
    extend(paneObj, attrs)
  end

  defm create
    unless self.open()
      if self.in_layout()
        self.layout.create_pane(self)
      else
        self.create_free()
      end
    end
  end

  defm create_free
    unless self.open()
      panes_before = maque#tmux#pane#all()
      maque#util#system(self.splitter(), 1)
      self.determine_id(panes_before)
      self.post_create()
    end
  end

  defm determine_id(panes_before)
    matcher = 'index(keys(a:panes_before), v:val) == -1'
    matches = filter(keys(maque#tmux#pane#all(1)), matcher)
    self.id = len(matches) > 0 ? matches[0] : -1
  end

  defm post_create
    if self.open()
      self.minimized = 0
      if self.create_minimized
        self.toggle()
      end
      self.send(' cd '.getcwd())
      self.set_shell_pid()
    end
  end

  defm make(cmd, *args)
    capture = get(args, 0, self.capture)
    autoclose = get(args, 0, self.autoclose)
    if self.ready_for_make()
      if self.minimized && self.restore_on_make
        self.restore()
      end
      self.send(cmd)
      if capture
        if !self.manual_termination
          " send the pipe canceling command now, so that it executes as soon as the
          " make command is finished
          " omit this if manual_termination is set, i.e. the program is
          " interactive or just doesn't terminate automatically (guard, log)
          self.send(' tmux '.self.pipe_cmd())
        end
        " initiate the pipe to the errorfile after starting the command, so that it
        " doesn't contain the command line
        self.pipe_to_file()
      end
      if autoclose
        self.send(' sleep '.self.wait_before_autoclose .'; exit')
      end
      if self.focus_on_make
        self.focus()
      end
    else
      maque#util#warn('make called on pane "'.self.name .'" while not open!')
    end
  end

  " Send a signal to the command.
  " Iterates g:maque_tmux_kill_signals for subsequent calls until the process
  " is dead (default INT, TERM, KILL)
  " Argument overrides the employed signal and does not advance the current
  " signal.
  defm kill(signal='0')
    force_signal = (signal != '0')
    if self.process_alive()
      if self.command_pid != self._last_killed
        self._killed = 0
        self._last_killed = self.command_pid
      end
      signal = next_signal(self._killed) unless force_signal
      self._kill(signal)
      self._killed += 1 unless force_signal
      return 1
    else
      maque#util#warn('no process running!')
    end
  end

  defm _kill(signal)
    maque#util#system('kill -'.signal.' '.self.command_pid, 1)
    maque#util#warn('sent SIG'.signal. " to pane '".self.name ."'!")
  end

  defm kill_wait
    for index in range(len(g:maque_tmux_kill_signals))
      self.kill()
      return 1 unless self.process_alive()
      sleep 1
      return 1 unless self.process_alive()
    end
    return !self.process_alive()
  end

  " execute a shell command in the target pane
  defm send(cmd)
    self.send_keys("'".cmd."' 'ENTER'")
  end

  " send input to the target pane
  defm send_keys(cmd)
    maque#tmux#command('send-keys -t '.self.id .' '.cmd)
  end

  defm open
    return has_key(maque#tmux#pane#all(), self.id)
  end

  " Kill the pane if it's open, reset pids in any case
  defm close
    if self.open()
      maque#tmux#command('kill-pane -t '.self.id)
    end
    self.command_pid = 0
    self.shell_pid = 0
  end

  defm toggle
    if self.open()
      if self.minimize_on_toggle
        self.toggle_minimized()
      else
        self.close()
      end
    else
      self.create()
    end
  end

  defm toggle_minimized
    if self.minimized
      self.restore()
    else
      self.minimize()
    end
  end

  " Store the current size and set the minimized_size.
  " Do not use the 'size' parameter for restoring, as the pane could have been
  " altered purposefully.
  defm minimize
    self._original_size = maque#tmux#pane#size(self.id)
    self._apply_size(self.minimized_size)
    self.minimized = 1
  end

  defm restore
    self.resize(self._original_size[0], self._original_size[1])
    self.minimized = 0
    self.focus() if self.focus_on_restore
  end

  " Apply the size given by the constructor parameters 'size' or
  " 'minimized_size', whichever is appropriate
  defm set_size
    return
    if self.minimized
      self._apply_size(self.minimized_size)
    elseif self.size
      self._original_size = maque#tmux#pane#size(self.id)
      self._apply_size(self.size)
    end
  end

  " FIXME need to discern between minimizing and setting the stacking size in
  " the layout's direction.
  defm _apply_size(size)
    if self._vertical()
      self.resize(size, self._original_size[1])
    else
      self.resize(self._original_size[0], size)
    end
  end

  defm resize(width, height)
    cmd = 'resize-pane -t '.self.id .' -x '.width .' -y '.height
    maque#tmux#command(cmd)
  end

  defm focus
    maque#tmux#command('select-pane -t '.self.id)
    if g:maque_tmux_map_focus_vim
      cmd = 'run "tmux last-pane; tmux unbind-key -n '.g:maque_tmux_focus_vim_key .'"'
      maque#tmux#command('bind-key -n '.g:maque_tmux_focus_vim_key .' '.cmd)
    end
  end

  defm pipe_to_file
    filter = g:maque_tmux_filter_escape_sequences ?
          \ g:maque_tmux_pane_escape_filter : 'tee'
    redirect = filter . ' > '.self.errorfile
    maque#tmux#command(self.pipe_cmd().' '.shellescape(redirect))
  end

  defm pipe_cmd
    return 'pipe-pane -t '.self.id
  end

  defm reset_capture
    maque#tmux#command(self.pipe_cmd())
    delete(self.errorfile)
    self.pipe_to_file()
  end

  defm description
    return 'tmux pane "'.self.name .'"'
  end

  defm splitter
    if self.in_layout()
      return self.layout.splitter()
    else
      if self.eval_splitter
        return eval(self._splitter)
      else
        return self._splitter
      end
    end
  end

  defm set_shell_pid
    panes = maque#tmux#pane#all()
    if has_key(panes, self.id)
      self.shell_pid = panes[self.id].pid
    end
  end

  defm set_command_pid
    self.command_pid = 0
    if self.open()
      pids = maque#util#child_pids(self.shell_pid)
      [pid, comm] = empty(pids) ? [0, ''] : pids[0]
      self.command_pid = pid
      self.command_executable = comm
    end
    return self.command_pid
  end

  defm set_command_executable
    self.set_command_pid()
    return self.command_executable
  end

  defm process_alive
    return self.set_command_pid() > 0
  end

  defm ready_for_make
    return self.open() && (!self.process_alive() || self._handle_running_process())
  end

  defm in_layout
    return type(self.layout) != type(0)
  end

  defm _handle_running_process
    if self.kill_running_on_make
      if self.kill_wait()
        return 1
      else
        maque#util#warn('Failed to kill running process!')
      end
    else
      maque#util#warn('Refusing to kill running process!')
    end
  end

  defm _vertical
    if self.in_layout()
      return self.layout.direction == 'vertical'
    else
      return self.vertical
    end
  end
end

def next_signal(idx)
  sigs = g:maque_tmux_kill_signals
  return sigs[min([idx, len(sigs)-1])]
end

def maque#tmux#pane#new(name, params={})
  return new Pane(name, params)
end

class VimPane < Pane

  def initialize(params={})
    super('vim', params)
  end

  defm open
    self.id = maque#tmux#vim_id() if self.id == -1
    return super()
  end
end

def maque#tmux#pane#new_vim(params={})
  return new VimPane(params)
end
