" FIXME pane_name is misleading as in eval mode, it is expected to return a
" Pane object
class Command

  def initialize(command, name, params={})
    if has_key(params, 'pane')
      params['pane_name'] = remove(params, 'pane')
    end
    attrs = {
          \ '_command': a:command,
          \ 'pane_name': 'main',
          \ 'handler': g:maque_handler,
          \ 'cmd_type': 'shell',
          \ 'pane_type': 'name',
          \ 'copy_to_main': 0,
          \ 'name': name,
          \ 'compiler': '',
          \ 'nested': 0,
          \ }
    extend(commandObj, attrs)
    extend(commandObj, params)
  end

  defm command
    return call(get(self, '_command_' . self.cmd_type), [], self)
  end

  defm _command_eval
    return eval(self._command)
  end

  defm _command_shell
    return self._command
  end

  defm cmd_compact
    return self.command()
  end

  defm make
    g:maque_making_command = self.name
    :silent doautocmd User MaqueCommandMake
    pane = self.pane()
    pane.compiler = self.compiler
    pane.nested = self.nested
    maque#set_main_command(self) if self.copy_to_main
    maque#make_pane(pane, self.command(), self.handler)
    :unlet g:maque_making_command
  end

  defm pane
    return call(get(self, '_pane_' . self.pane_type), [], self)
  end

  defm _pane_eval
    try
      return eval(self.pane_name)
    catch
      echo v:exception
      return self._pane_name
    end
  end

  defm _pane_name
    return maque#pane(self.pane_name)
  end

  " kill the process running in the target pane, and, if this succeeds or there
  " was none running, run the command.
  defm restart
    if self.kill()
      call self.make()
    endif
  end

  defm kill
    return self.pane().kill_wait()
  end

  defm running
    return self.pane().process_alive()
  end

  defm stopped
    return !self.running() || self.nested
  end

  defm toggle
    pane = self.pane()
    if pane.process_alive()
      pane.toggle()
    else
      self.make()
    end
  end
end

def maque#command#new(*args)
  return new Command(*args)
end

class RemoteVim < Command

  def initialize(name, params)
    super('', name, extend({ 'main': 0 }, params))
  end

  defm command
    arg = 'let g:maque_remote = 1'
    cmd = "#{self.base_command()} --cmd ".'"'."#{arg}".'"'
    return cmd
  end

  def base_command
    return "vim --servername #{self.server_name()}"
  end

  defm cmd_compact
    return "remote vim #{self.server_name()}"
  end

  defm execute(cmdline)
    self.remote('send', ":#{cmdline}<cr>")
  end

  defm eval(expr)
    self.remote('expr', expr)
  end

  defm remote(method, args)
    self.launch_vim()
    esc = escape(args, "'".'"')
    cmd = "#{self.base_command()} --remote-#{method} ".'"'."#{esc}".'"'
    maque#util#system(cmd)
  end

  defm launch_vim
    pane = self.pane()
    if type(pane) == type({}) && !pane.process_alive()
      echo 'maque: launching remote vim.'
      self.make()
      maque#util#wait_until("maque#util#server_alive('#{self.server_name()}')",
            \ 25)
    end
  end

  defm server_name
    unless has_key(self, '_server_name')
      if self.main
        self._server_name = v:servername
      else
        id = maque#tmux#vim_id()
        self._server_name = "maque_#{id}_#{self.name}"
      end
    end
    return self._server_name
  end
end

def maque#command#new_vim(name, args)
  return new RemoteVim(name, args)
end

class MainVim < RemoteVim

  def initialize()
    super('main_vim', { 'pane_name': 'vim', 'main': 1 })
  end

  defm server_name
    return v:servername
  end
end

def maque#command#new_main_vim()
  return new MainVim()
end

class VimCommand < Command

  def initialize(*args)
    super(*args)
  end

  defm make
    :execute self.command()
  end
end

def maque#command#new_vim_command(*args)
  return new VimCommand(*args)
end
