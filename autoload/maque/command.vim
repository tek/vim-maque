"
" This file was automatically generated by riml 0.4.0
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

function! s:CommandConstructor(command, name, ...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let params = remove(__splat_var_cpy, 0)
  else
    let params = {}
  endif
  let commandObj = {}
  if has_key(params, 'pane')
    let params['pane_name'] = remove(params, 'pane')
  endif
  let attrs = {'_command': a:command, 'pane_name': 'main', 'handler': g:maque_handler, 'cmd_type': 'shell', 'pane_type': 'name', 'remember': 0, 'name': a:name, 'compiler': '', 'shell': '', 'deps': [], 'envs': [], 'current_env': 0, 'capture': 1}
  call extend(commandObj, attrs)
  call extend(commandObj, params)
  let commandObj.command = function('<SNR>' . s:SID() . '_Command_command')
  let commandObj._command_eval = function('<SNR>' . s:SID() . '_Command__command_eval')
  let commandObj._command_shell = function('<SNR>' . s:SID() . '_Command__command_shell')
  let commandObj.cmd_compact = function('<SNR>' . s:SID() . '_Command_cmd_compact')
  let commandObj.run_in_shell = function('<SNR>' . s:SID() . '_Command_run_in_shell')
  let commandObj.shell_cmd = function('<SNR>' . s:SID() . '_Command_shell_cmd')
  let commandObj.run_deps = function('<SNR>' . s:SID() . '_Command_run_deps')
  let commandObj.make = function('<SNR>' . s:SID() . '_Command_make')
  let commandObj.make_cmdline = function('<SNR>' . s:SID() . '_Command_make_cmdline')
  let commandObj.shell_make = function('<SNR>' . s:SID() . '_Command_shell_make')
  let commandObj.make_directly = function('<SNR>' . s:SID() . '_Command_make_directly')
  let commandObj.queue = function('<SNR>' . s:SID() . '_Command_queue')
  let commandObj.pane = function('<SNR>' . s:SID() . '_Command_pane')
  let commandObj._pane_by_eval = function('<SNR>' . s:SID() . '_Command__pane_by_eval')
  let commandObj._pane_by_name = function('<SNR>' . s:SID() . '_Command__pane_by_name')
  let commandObj.ensure_running = function('<SNR>' . s:SID() . '_Command_ensure_running')
  let commandObj.restart = function('<SNR>' . s:SID() . '_Command_restart')
  let commandObj.kill = function('<SNR>' . s:SID() . '_Command_kill')
  let commandObj.running = function('<SNR>' . s:SID() . '_Command_running')
  let commandObj.stopped = function('<SNR>' . s:SID() . '_Command_stopped')
  let commandObj.toggle = function('<SNR>' . s:SID() . '_Command_toggle')
  return commandObj
endfunction

function! s:Command_command() dict
  return call(get(self, '_command_' . self.cmd_type), [], self)
endfunction

function! s:Command__command_eval() dict
  return eval(self._command)
endfunction

function! s:Command__command_shell() dict
  return self._command
endfunction

function! s:Command_cmd_compact() dict
  return self.command()
endfunction

function! s:Command_run_in_shell() dict
  if len(self.shell) ># 0
    if has_key(g:maque_commands, self.shell)
      return 1
    else
      call maque#util#error('no such shell command: ' . self.shell . '(' . self.name . ')')
      return 0
    endif
  else
    return 0
  endif
endfunction

function! s:Command_shell_cmd() dict
  return maque#command(self.shell)
endfunction

function! s:Command_run_deps() dict
  for n in self.deps
    if has_key(g:maque_commands, n)
      call maque#command(n).ensure_running()
    else
      call maque#util#error('no such command: ' . n . '(' . self.name . ' dependency)')
    endif
  endfor
endfunction

function! s:Command_make(...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let replace = remove(__splat_var_cpy, 0)
  else
    let replace = 1
  endif
  call self.make_cmdline(self.command(), replace)
endfunction

function! s:Command_make_cmdline(cmdline, ...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let replace = remove(__splat_var_cpy, 0)
  else
    let replace = 1
  endif
  if self.run_in_shell()
    call self.shell_cmd().shell_make(a:cmdline, replace)
  else
    call self.make_directly(a:cmdline, replace)
  endif
  if self.remember
    call maque#set_last_command(self)
  endif
endfunction

function! s:Command_shell_make(cmdline, ...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let replace = remove(__splat_var_cpy, 0)
  else
    let replace = 1
  endif
  call self.ensure_running()
  let pane = self.pane()
  let pane.shell = 1
  call self.make_cmdline(a:cmdline, replace)
endfunction

function! s:Command_make_directly(cmdline, ...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let replace = remove(__splat_var_cpy, 0)
  else
    let replace = 1
  endif
  let g:maque_making_command = self.name
  call maque#util#mautocmd('CommandMake')
  call self.run_deps()
  let pane = self.pane()
  let pane.compiler = self.compiler
  call maque#make_pane(pane, a:cmdline, self.handler, replace, self.capture)
  let g:maque_making_command = ''
endfunction

function! s:Command_queue() dict
  call self.make(0)
endfunction

function! s:Command_pane() dict
  let p = call(get(self, '_pane_by_' . self.pane_type), [], self)
  try
    let n = p.name
  catch //
    throw 'command ''' . self.name . ''' is missing its pane ''' . self.pane_name . ''''
  endtry
  return p
endfunction

function! s:Command__pane_by_eval() dict
  try
    return eval(self.pane_name)
  catch
    echo v:exception
    return self._pane_by_name
  endtry
endfunction

function! s:Command__pane_by_name() dict
  return maque#pane(self.pane_name)
endfunction

function! s:Command_ensure_running() dict
  if !self.running()
    call self.make()
  endif
endfunction

function! s:Command_restart() dict
  if self.kill()
    call self.make()
  endif
endfunction

function! s:Command_kill() dict
  return self.pane().kill_wait()
endfunction

function! s:Command_running() dict
  return self.pane().process_alive()
endfunction

function! s:Command_stopped() dict
  return self.run_in_shell() || !self.running()
endfunction

function! s:Command_toggle() dict
  let pane = self.pane()
  if !self.run_in_shell() && pane.process_alive()
    call pane.toggle()
  else
    call self.make()
  endif
endfunction

function! maque#command#new(...)
  return call('s:CommandConstructor', a:000)
endfunction

function! s:RemoteVimConstructor(name, params)
  let remoteVimObj = {}
  let commandObj = s:CommandConstructor('', a:name, extend({'main': 0}, a:params))
  call extend(remoteVimObj, commandObj)
  let remoteVimObj.command = function('<SNR>' . s:SID() . '_RemoteVim_command')
  let remoteVimObj.cmd_compact = function('<SNR>' . s:SID() . '_RemoteVim_cmd_compact')
  let remoteVimObj.execute = function('<SNR>' . s:SID() . '_RemoteVim_execute')
  let remoteVimObj.eval = function('<SNR>' . s:SID() . '_RemoteVim_eval')
  let remoteVimObj.remote = function('<SNR>' . s:SID() . '_RemoteVim_remote')
  let remoteVimObj.launch_vim = function('<SNR>' . s:SID() . '_RemoteVim_launch_vim')
  let remoteVimObj.server_name = function('<SNR>' . s:SID() . '_RemoteVim_server_name')
  return remoteVimObj
endfunction

function! s:RemoteVim_base_command(remoteVimObj)
  return "vim --servername " . a:remoteVimObj.server_name()
endfunction

function! s:RemoteVim_command() dict
  let arg = 'let g:maque_remote = 1'
  let cmd = s:RemoteVim_base_command(self) . " --cmd " . '"' . arg . '"'
  return cmd
endfunction

function! s:RemoteVim_cmd_compact() dict
  return "remote vim " . self.server_name()
endfunction

function! s:RemoteVim_execute(cmdline) dict
  call self.remote('send', ":" . a:cmdline . "<cr>")
endfunction

function! s:RemoteVim_eval(expr) dict
  call self.remote('expr', a:expr)
endfunction

function! s:RemoteVim_remote(method, args) dict
  call self.launch_vim()
  let esc = escape(a:args, "'" . '"')
  let cmd = s:RemoteVim_base_command(self) . " --remote-" . a:method . " " . '"' . esc . '"'
  call maque#util#system(cmd)
endfunction

function! s:RemoteVim_launch_vim() dict
  let pane = self.pane()
  if type(pane) ==# type({}) && !pane.process_alive()
    echo 'maque: launching remote vim.'
    call self.make()
    call maque#util#wait_until("maque#util#server_alive('" . self.server_name() . "')", 25)
  endif
endfunction

function! s:RemoteVim_server_name() dict
  if !(has_key(self, '_server_name'))
    if self.main
      let self._server_name = v:servername
    else
      let self._server_name = "maque_" . g:maque_tmux_vim_pane_id . "_" . self.name
    endif
  endif
  return self._server_name
endfunction

function! maque#command#new_vim(name, args)
  return s:RemoteVimConstructor(a:name, a:args)
endfunction

function! s:MainVimConstructor()
  let mainVimObj = {}
  let remoteVimObj = s:RemoteVimConstructor('main_vim', {'pane_name': 'vim', 'main': 1})
  call extend(mainVimObj, remoteVimObj)
  let mainVimObj.server_name = function('<SNR>' . s:SID() . '_MainVim_server_name')
  return mainVimObj
endfunction

function! s:MainVim_server_name() dict
  return v:servername
endfunction

function! maque#command#new_main_vim()
  return s:MainVimConstructor()
endfunction

function! s:VimCommandConstructor(...)
  let vimCommandObj = {}
  let commandObj = call('s:CommandConstructor', a:000)
  call extend(vimCommandObj, commandObj)
  let vimCommandObj.make = function('<SNR>' . s:SID() . '_VimCommand_make')
  return vimCommandObj
endfunction

function! s:VimCommand_make() dict
  execute self.command()
endfunction

function! maque#command#new_vim_command(...)
  return call('s:VimCommandConstructor', a:000)
endfunction

function! s:ShellConstructor(...)
  let shellObj = {}
  let commandObj = call('s:CommandConstructor', a:000)
  call extend(shellObj, commandObj)
  return shellObj
endfunction

function! maque#command#new_shell(...)
  return call('s:ShellConstructor', a:000)
endfunction

function! maque#command#init()
  if maque#util#want('add_default_commands') && maque#util#not_want('remote', 'default_commands_added')
    call maque#command#start_default_commands()
    call maque#util#mautocmd('CommandsCreated')
  endif
endfunction

function! maque#command#start_default_commands()
  let g:maque_main_vim = maque#command#new_main_vim()
  call maque#create_command('auto', 'maque#auto_prg()', {'cmd_type': 'eval', 'pane_type': 'eval', 'pane_name': 'maque#current_pane()', 'remember': 1})
  call maque#create_command('main', 'g:maque_mainprg', {'cmd_type': 'eval', 'pane_type': 'eval', 'pane_name': 'maque#current_pane()', 'remember': 1})
  let g:maque_status = maque#command#new_vim('status', {'pane_name': 'status'})
  let commands = maque#commands()
  let commands['status'] = g:maque_status
  let g:maque_default_commands_added = 1
endfunction

function! maque#command#quit()
  unlet! g:maque_main_vim
  unlet! g:maque_status
  unlet! g:maque_auto
  let g:maque_commands = {}
endfunction
