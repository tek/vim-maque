"
" This file was automatically generated by riml 0.4.0
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

" included: 'view.riml'
function! g:ViewConstructor(name, ...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let params = remove(__splat_var_cpy, 0)
  else
    let params = {}
  endif
  let viewObj = {}
  let viewObj.name = a:name
  let attrs = {'_original_size': [0, 0], 'minimized': 0, 'minimized_size': 2, 'minimize_on_toggle': get(g:, 'maque_tmux_minimize_on_toggle', 0), 'focus_on_restore': 0, 'vertical': 1, 'size': 0}
  call extend(attrs, params)
  let attrs.minimized_size = max([attrs.minimized_size, 2])
  call extend(viewObj, attrs)
  let viewObj.toggle = function('<SNR>' . s:SID() . '_View_toggle')
  let viewObj.toggle_minimized = function('<SNR>' . s:SID() . '_View_toggle_minimized')
  let viewObj.minimize = function('<SNR>' . s:SID() . '_View_minimize')
  let viewObj.restore = function('<SNR>' . s:SID() . '_View_restore')
  let viewObj.apply_size = function('<SNR>' . s:SID() . '_View_apply_size')
  let viewObj._vertical = function('<SNR>' . s:SID() . '_View__vertical')
  let viewObj.fixed_size = function('<SNR>' . s:SID() . '_View_fixed_size')
  let viewObj.effective_size = function('<SNR>' . s:SID() . '_View_effective_size')
  let viewObj.layout_size = function('<SNR>' . s:SID() . '_View_layout_size')
  let viewObj.layout_position = function('<SNR>' . s:SID() . '_View_layout_position')
  let viewObj.pack_layout = function('<SNR>' . s:SID() . '_View_pack_layout')
  let viewObj.pack = function('<SNR>' . s:SID() . '_View_pack')
  return viewObj
endfunction

function! s:View_toggle() dict
  if self.open()
    if self.minimize_on_toggle
      call self.toggle_minimized()
    else
      call self.close()
    endif
  else
    call self.create()
  endif
endfunction

function! s:View_toggle_minimized() dict
  if self.minimized
    call self.restore()
  else
    call self.minimize()
  endif
endfunction

function! s:View_minimize() dict
  if self.open() && !self.minimized
    let self._original_size = self.current_size()
    if !(self.in_layout())
      call self.apply_size(self.minimized_size)
    endif
    let self.minimized = 1
    call self.pack_layout()
  endif
endfunction

function! s:View_restore() dict
  if self.open() && self.minimized
    if !(self.in_layout())
      call self.resize(self._original_size[0], self._original_size[1])
    endif
    let self.minimized = 0
    if self.focus_on_restore
      call self.focus()
    endif
    call self.pack_layout()
  endif
endfunction

function! s:View_apply_size(size, ...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let both = remove(__splat_var_cpy, 0)
  else
    let both = 0
  endif
  let secondary = both ? self._original_size[!self._vertical()] : 0
  if self._vertical()
    call self.resize(secondary, a:size)
  else
    call self.resize(a:size, secondary)
  endif
endfunction

function! s:View__vertical() dict
  if self.in_layout()
    return self.layout.layout_vertical()
  else
    return self.vertical
  endif
endfunction

function! s:View_fixed_size() dict
  return self.size !=# 0 || self.minimized
endfunction

function! s:View_effective_size() dict
  return (self.minimized ? self.minimized_size : self.size) + 0
endfunction

function! s:View_layout_size() dict
  return self.current_size()[self._vertical()] + 0
endfunction

function! s:View_layout_position() dict
  return self.current_position()[self._vertical()] + 0
endfunction

function! s:View_pack_layout() dict
  if self.in_layout()
    call self.layout.pack()
  endif
  call self.pack()
endfunction

function! s:View_pack() dict
endfunction

function! maque#tmux#layout#cmp_pane_height(p1, p2)
  let pos1 = a:p1.layout_position()
  let pos2 = a:p2.layout_position()
  return pos1 ==# pos2 ? 0 : pos1 ># pos2 ? 1 : -1
endfunction

function! s:LayoutConstructor(name, args)
  let layoutObj = {}
  let viewObj = g:ViewConstructor(a:name, a:args)
  call extend(layoutObj, viewObj)
  let layoutObj.panes = []
  let layoutObj.direction = get(a:args, 'direction', 'vertical')
  let layoutObj.layout = 0
  let layoutObj.add = function('<SNR>' . s:SID() . '_Layout_add')
  let layoutObj.create = function('<SNR>' . s:SID() . '_Layout_create')
  let layoutObj.create_pane = function('<SNR>' . s:SID() . '_Layout_create_pane')
  let layoutObj.pack = function('<SNR>' . s:SID() . '_Layout_pack')
  let layoutObj.pack_pane = function('<SNR>' . s:SID() . '_Layout_pack_pane')
  let layoutObj.close = function('<SNR>' . s:SID() . '_Layout_close')
  let layoutObj.open = function('<SNR>' . s:SID() . '_Layout_open')
  let layoutObj.focus = function('<SNR>' . s:SID() . '_Layout_focus')
  let layoutObj.split = function('<SNR>' . s:SID() . '_Layout_split')
  let layoutObj.target_pane_param = function('<SNR>' . s:SID() . '_Layout_target_pane_param')
  let layoutObj.set_preferred_size = function('<SNR>' . s:SID() . '_Layout_set_preferred_size')
  let layoutObj.current_size = function('<SNR>' . s:SID() . '_Layout_current_size')
  let layoutObj.resize = function('<SNR>' . s:SID() . '_Layout_resize')
  let layoutObj.splitter = function('<SNR>' . s:SID() . '_Layout_splitter')
  let layoutObj.creator = function('<SNR>' . s:SID() . '_Layout_creator')
  let layoutObj.in_layout = function('<SNR>' . s:SID() . '_Layout_in_layout')
  let layoutObj.determine_id = function('<SNR>' . s:SID() . '_Layout_determine_id')
  let layoutObj.post_create = function('<SNR>' . s:SID() . '_Layout_post_create')
  let layoutObj.create_kids = function('<SNR>' . s:SID() . '_Layout_create_kids')
  let layoutObj.create_and_wait = function('<SNR>' . s:SID() . '_Layout_create_and_wait')
  let layoutObj.ref_pane = function('<SNR>' . s:SID() . '_Layout_ref_pane')
  let layoutObj.pane_id = function('<SNR>' . s:SID() . '_Layout_pane_id')
  let layoutObj.current_size = function('<SNR>' . s:SID() . '_Layout_current_size')
  let layoutObj.current_position = function('<SNR>' . s:SID() . '_Layout_current_position')
  let layoutObj.stretch_size = function('<SNR>' . s:SID() . '_Layout_stretch_size')
  let layoutObj.layout_vertical = function('<SNR>' . s:SID() . '_Layout_layout_vertical')
  return layoutObj
endfunction

function! s:Layout_open_panes(layoutObj)
  let panes = []
  for pane in a:layoutObj.panes
    if pane.open()
      call add(panes, pane)
    endif
  endfor
  return panes
endfunction

function! s:Layout_open_panes_sorted(layoutObj)
  return sort(s:Layout_open_panes(a:layoutObj), 'maque#tmux#layout#cmp_pane_height')
endfunction

function! s:Layout_any_pane(layoutObj)
  return s:Layout_open_panes(a:layoutObj)[0]
endfunction

function! s:Layout_add(pane) dict
  call add(self.panes, a:pane)
  let a:pane.layout = self
endfunction

function! s:Layout_create() dict
  if !(self.open())
    if self.in_layout() && len(self.panes) ># 0
      call self.layout.create_pane(self.panes[0])
    else
      call maque#tmux#command_output(self.creator())
    endif
  endif
endfunction

function! s:Layout_create_pane(pane) dict
  if self.in_layout()
    call self.layout.create_kids()
  endif
  let panes_before = maque#tmux#pane#all()
  if !(a:pane.open())
    if self.open()
      call self.split(a:pane)
      call maque#tmux#pane('vim').focus()
    else
      call self.create()
    endif
    call a:pane.determine_id(panes_before)
    call a:pane.post_create()
    call self.pack()
  endif
endfunction

function! s:Layout_pack() dict
  if !g:maque_tmux_exiting
    let stretch_size = self.stretch_size()
    for pane in s:Layout_open_panes(self)
      call self.pack_pane(pane, stretch_size)
    endfor
  endif
endfunction

function! s:Layout_pack_pane(pane, stretch_size) dict
  if a:pane.fixed_size()
    call a:pane.set_preferred_size()
  else
    call a:pane.apply_size(a:stretch_size)
  endif
endfunction

function! s:Layout_close() dict
  for pane in s:Layout_open_panes(self)
    call pane.close()
  endfor
endfunction

function! s:Layout_open() dict
  return !empty(s:Layout_open_panes(self))
endfunction

function! s:Layout_focus() dict
  if self.open()
    let pane = self.ref_pane()
    call pane.focus()
  endif
endfunction

function! s:Layout_split(pane) dict
  let splitter = self.splitter() . ' ' . self.target_pane_param() . ' ' . a:pane.splitter_params()
  call maque#tmux#command_output(splitter)
endfunction

function! s:Layout_target_pane_param() dict
  return '-t ' . self.pane_id()
endfunction

function! s:Layout_set_preferred_size() dict
  if self.open()
    call self.ref_pane().set_preferred_size()
  endif
endfunction

function! s:Layout_current_size() dict
  if self.open()
    return self.ref_pane().current_size()
  else
    return [0, 0]
  endif
endfunction

function! s:Layout_resize(width, height) dict
  if self.open()
    call self.ref_pane().resize(a:width, a:height)
  endif
endfunction

function! s:Layout_splitter() dict
  return self.layout_vertical() ? 'splitw -v -d' : 'splitw -h -d'
endfunction

function! s:Layout_creator() dict
  return self.layout_vertical() ? 'splitw -h -d' : 'splitw -v -d'
endfunction

function! s:Layout_in_layout() dict
  return type(self.layout) !=# type(0)
endfunction

function! s:Layout_determine_id(...) dict
endfunction

function! s:Layout_post_create() dict
endfunction

function! s:Layout_create_kids() dict
  for pane in self.panes
    if !(pane.open())
      call pane.create_and_wait()
    endif
  endfor
endfunction

function! s:Layout_create_and_wait(...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let timeout = remove(__splat_var_cpy, 0)
  else
    let timeout = 5
  endif
  call self.create()
  let counter = 0
  while (!self.open()) && (counter <# timeout * 10)
    sleep 100m
    let counter += 1
  endwhile
endfunction

function! s:Layout_ref_pane() dict
  let panes = s:Layout_open_panes_sorted(self)
  return panes[0]
endfunction

function! s:Layout_pane_id() dict
  return self.ref_pane().pane_id()
endfunction

function! s:Layout_current_size() dict
  return s:Layout_any_pane(self).current_size()
endfunction

function! s:Layout_current_position() dict
  return s:Layout_any_pane(self).current_position()
endfunction

function! s:Layout_stretch_size() dict
  let total_size = 0
  let fixed_pane_size = 0
  let stretch_count = 0
  let index = self.layout_vertical() ? 1 : 0
  for pane in s:Layout_open_panes(self)
    let total_size += pane.current_size()[index]
    if pane.fixed_size()
      let fixed_pane_size += pane.effective_size()
    else
      let stretch_count += 1
    endif
  endfor
  return stretch_count ? ((total_size - fixed_pane_size) / stretch_count) : 0
endfunction

function! s:Layout_layout_vertical() dict
  return self.direction ==# 'vertical'
endfunction

function! maque#tmux#layout#new(name, ...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let args = remove(__splat_var_cpy, 0)
  else
    let args = {}
  endif
  return s:LayoutConstructor(a:name, args)
endfunction

function! s:WindowConstructor(name, args)
  let windowObj = {}
  let layoutObj = s:LayoutConstructor(a:name, a:args)
  call extend(windowObj, layoutObj)
  let windowObj.creator = function('<SNR>' . s:SID() . '_Window_creator')
  return windowObj
endfunction

function! s:Window_creator() dict
  return 'neww -d'
endfunction

function! maque#tmux#layout#new_window(name, ...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let args = remove(__splat_var_cpy, 0)
  else
    let args = {}
  endif
  return s:WindowConstructor(a:name, args)
endfunction
